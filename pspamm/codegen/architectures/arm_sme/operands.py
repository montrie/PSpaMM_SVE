from pspamm.codegen.operands import *


AsmType = Enum('AsmType', [asmtype.name for asmtype in AsmType] + ['za8', 'za16', 'za32', 'za64', 'za128'])


class Operand_ARM:
    @property
    def ugly(self):
        raise NotImplementedError()


class Constant_ARM(Constant):
    @property
    def ugly(self):
        return "#{}".format(self.value)

    @property
    def ugly_large(self):
        return "={}".format(self.value)

    @property
    def ugly_lower16(self):
        return "#:lower16:{}".format(self.value)

    @property
    def ugly_upper16(self):
        return "#:upper16:{}".format(self.value)


def c(n):
    """Sugar for conveniently defining integer constants"""
    return Constant_ARM(value=int(n))


class Label_ARM(Label):
    @property
    def ugly(self):
        # return self.ordinal
        return self.value.upper() + "_%="


def l(label: str):
    return Label_ARM(label)


class Register_ARM(Register):
    @property
    def ugly(self):
        return self.value

    @property
    def ugly_precision(self):
        return self.value.split(".")[1]

    @property
    def ugly_lsl_shift(self):
        return 3 if self.ugly_precision == "d" else 2

    @property
    def clobbered(self):
        # removed [this comment should stay here for now---in case there's some compiler expecting it]: .replace("x", "r")
        return (self.value.split(".")[0])

    @property
    def ugly_scalar(self):
        return (self.value.split(".")[0]).replace("v", "q")

    @property
    def ugly_scalar_1d(self):
        #turns "Vn.2d" into "Dn"
        return (self.value.split(".")[0]).replace("v", "d")

    @property
    def ugly_1d(self):
        return self.value.replace("2d", "1d")


class Register_ZA(Register):

    def __init__(self, typeinfo, value, tile, base, offset) -> None:
        super().__init__(typeinfo, value)
        self.tile = tile
        self.base = base
        self.offset = offset

    @property
    def clobbered(self):
        # TODO: placeholder fix, we might want to make Register_ZA a subclass of Operand 
        # instead of register, because Register objects are sometimes added to the clobbered list
        return "memory"

    @property
    def ugly(self):
        # access the tile-th horizontal slice of the ZA register
        return "za{}h.{}{}".format(self.tile, self.ugly_precision, self.ugly_mem)

    @property
    def ugly_register(self):
        return "za{}.{}".format(self.tile, self.ugly_precision)

    @property
    def ugly_slice(self):
        return "za{}".format(self.ugly_mem)

    @property
    def ugly_mem(self):
        return "[{}, #{}]".format(self.ugly_base, self.offset)

    @property
    def ugly_base(self):
        return "{}".format(self.base.ugly).replace("x", "w")

    @property
    def ugly_offset(self):
        return "{}".format(self.offset)

    @property
    def ugly_precision(self):
        return "{}".format(self.value[-1]) #.split(".")[1]

    @property
    def ugly_lsl_shift(self):
        return {
            "d": 3,
            "s": 2,
            "h": 1
        }[self.ugly_precision]


r = lambda n: Register_ARM(AsmType.i64, "x" + str(n))
xzr = Register_ARM(AsmType.i64, "xzr")
z = lambda n, prec: Register_ARM(AsmType.f64x8, "z" + str(n) + "." + prec)
za = lambda prec, tile, base, offset: Register_ZA(AsmType.za, f"ZA.{prec}", tile, base, offset)  # TODO: info of form (base, offset)
# TODO: maybe just create a new Register class for the ZA tile to make this easier


class MemoryAddress_ARM(MemoryAddress):
    @property
    def ugly(self):
        # from the specifications:
        # Contiguous load of doublewords to elements of a vector register from the memory address generated by
        # a 64-bit scalar base and immediate index in the range -8 to 7 which is multiplied by the vector's
        # in-memory size, irrespective of predication, and added to the base address. Inactive elements will not
        # not cause a read from Device memory or signal a fault, and are set to zero in the destination vector.
        # MUL VL should multiply 64 on top of the immediate offset?
        return "[{}, {}, MUL VL]".format(self.base.ugly, self.disp)

    @property
    def clobbered(self):
        return self.base

    @property
    def ugly_no_vl_scaling(self):
        return "[{}, {}]".format(self.base.ugly, self.disp)

    @property
    def ugly_base(self):
        return "{}".format(self.base.ugly)

    @property
    def ugly_offset(self):
        # TODO: is this already dynamic? -> if precision is single, we need LSL #2
        return "{}".format(self.disp)


def mem(base, offset):
    return MemoryAddress_ARM(base, offset)
